var documenterSearchIndex = {"docs":
[{"location":"perms/#Permutations-(Perms)","page":"Permutations (Perms)","title":"Permutations (Perms)","text":"","category":"section"},{"location":"perms/#PermGroups.Perms","page":"Permutations (Perms)","title":"PermGroups.Perms","text":"This  module implements  permutations and  associated functions. It depends only on the package Combinat.\n\nWe  follow the design of permutations  in the GAP language. Perms are  permutations of the  set 1:n, represented  internally as a vector of n  integers holding the  images of 1:n.  The integer n  is called the degree  of the permutation. In this module,  as in GAP (and contrary to the philosophy  of Magma or the package Permutations.jl), two permutations of different degrees can be multiplied (the result has the larger degree). Two permutations are equal if and only if they move the same points in the same way,  so two permutations of  different degree can be  equal; the degree is thus  an implementation detail so usually it should not be used. One should rather use the function last_moved.\n\nThis  design makes it  easy to multiply  permutations coming from different groups, like a group and one of its subgroups. It has a negligible overhead compared to the design where the degree is fixed.\n\nThe default constructor for a permutation uses the list of images of 1:n, like  Perm([2,3,1,5,4,6]).  Often  it  is  more  convenient  to use cycle decompositions:    the   above   permutation    has   cycle   decomposition (1,2,3)(4,5)    thus   can   be    written   Perm(1,2,3)*Perm(4,5)   or perm\"(1,2,3)(4,5)\";  this last form  can parse a  permutation coming from GAP or the default printing at the REPL. The list of images of 1:n can be recovered  from the permutation  by the function  perm; note that equal  permutations with different degrees  will have different perm. The default  constructor tests the validity of the input by calling the julia function  isperm. To  have a  faster constructor  which does not test the input, use the keyword argument check=false.\n\nThe complete type of a permutation is Perm{T} where T<:Integer, so that Vector{T}  is the type of the vector which holds the image of 1:n. This can be used to save space or time. For instance Perm{UInt8}(1,2,3) can be used for Weyl groups of rank≤8 since they permute at most 240 roots. If T is  not specified we take it to be  Int16 since this is a good compromise between   speed,  compactness  and  possible  size  of  n.  One  can  mix permutations of different integer types; they are promoted to the wider one when multiplying.\n\nExamples of operations with permutations\n\njulia> a=Perm(1,2,3)\n(1,2,3)\n\njulia> perm(a)\n3-element Vector{Int16}:\n 2\n 3\n 1\n\njulia> a==Perm(perm(a))\ntrue\n\njulia> b=Perm(1,2,3,4)\n(1,2,3,4)\n\njulia> a*b     # product\n(1,3,2,4)\n\njulia> inv(a)  # inverse\n(1,3,2)\n\njulia> a/b     # quotient  a*inv(b)\n(3,4)\n\njulia> a\\b     # left quotient inv(a)*b\n(1,4)\n\njulia> a^b     # conjugation inv(b)*a*b\n(2,3,4)\n\njulia> b^2     # square\n(1,3)(2,4)\n\njulia> 1^a     # image by a of point 1\n2\n\njulia> one(a)  # trivial permutation\n()\n\njulia> sign(a) # signature of permutation\n1\n\njulia> order(a) # order (least trivial power) of permutation\n3\n\njulia> last_moved(a)\n3\n\njulia> first_moved(a)\n1\n\njulia> Perm{Int8}(a) # convert a to Perm{Int8}\nPerm{Int8}: (1,2,3)\n\njulia> Matrix(b)  # permutation matrix of b\n4×4 Matrix{Bool}:\n 0  1  0  0\n 0  0  1  0\n 0  0  0  1\n 1  0  0  0\n\njulia> randPerm(10) # random permutation of 1:10\n(1,8,4,2,9,7,5,10,3,6)\n\nPerms have methods copy, hash, ==, so they can be keys in hashes or elements  of sets; two permutations are equal  if they move the same points to  the same images. They have methods cmp, isless (lexicographic order on   moved  points)  so  they  can  be  sorted.  Perms  are  scalars  for broadcasting.\n\nOther  methods on  permutations are  cycles, cycletype, reflection_length,  mappingPerm,  restricted, support,        sortPerm,        Perm_rowcol, preimage, randPerm.\n\nNo  method is given in  this module to enumerate  Perms; you can use the method  permutations from Combinat,  iterate Combinat.Permutations or iterate the elements of symmetric_group from PermGroups.\n\n\n\n\n\n","category":"module"},{"location":"perms/#PermGroups.Perms.Perm","page":"Permutations (Perms)","title":"PermGroups.Perms.Perm","text":"struct Perm{T<:Integer}\n\nA  Perm represents a permutation  of the set 1:n  and is implemented by a struct  with one field,  a Vector{T} holding  the images of 1:n. When showing  a Perm at the REPL, the cycle decomposition is displayed as well as the type if it is not Int16. The default constructor checks the input, unless the keyword argument check=false is given.\n\njulia> Perms.Perm_(UInt8[1,3,2,4])\nPerm{UInt8}: (2,3)\n\n\n\n\n\n","category":"type"},{"location":"perms/#PermGroups.Perms.Perm-Union{NTuple{N, T1}, Tuple{N}, Tuple{T1}, Tuple{T}} where {T<:Integer, T1<:Integer, N}","page":"Permutations (Perms)","title":"PermGroups.Perms.Perm","text":"Perm{T}(x::Integer...)where T<:Integer\n\nreturns  a cycle.  For example  Perm{Int8}(1,2,3) constructs the cycle (1,2,3) as a Perm{Int8}. If omitted {T} is taken to be {Int16}.\n\n\n\n\n\n","category":"method"},{"location":"perms/#PermGroups.Perms.Perm-Tuple{AbstractMatrix{<:Integer}}","page":"Permutations (Perms)","title":"PermGroups.Perms.Perm","text":"Perm{T}(x::Integer...)where T<:Integer\n\nreturns  a cycle.  For example  Perm{Int8}(1,2,3) constructs the cycle (1,2,3) as a Perm{Int8}. If omitted {T} is taken to be {Int16}.\n\n\n\n\n\nPerm{T}(m::AbstractMatrix) If  m is a  permutation matrix, returns  the corresponding permutation of type T. If omitted, T is taken to be Int16.\n\njulia> Perm([0 1 0;0 0 1;1 0 0])\n(1,2,3)\n\n\n\n\n\n","category":"method"},{"location":"perms/#PermGroups.Perms.Perm-Tuple{AbstractVector, AbstractVector}","page":"Permutations (Perms)","title":"PermGroups.Perms.Perm","text":"Perm{T}(l::AbstractVector,l1::AbstractVector)\n\nreturns  p, a  Perm{T}, such  that invpermute(l1,p)==l  if such a p exists;  returns nothing  otherwise. If  not given  {T} is  taken to be {Int16}. Needs the eltype of l and l1 to be sortable.\n\njulia> Perm([0,2,4],[4,0,2])\n(1,3,2)\n\n\n\n\n\n","category":"method"},{"location":"perms/#PermGroups.Perms.Perm-Tuple{AbstractMatrix, AbstractMatrix}","page":"Permutations (Perms)","title":"PermGroups.Perms.Perm","text":"Perm{T}(m::AbstractMatrix,m1::AbstractMatrix;dims=1)\n\nreturns  p, a Perm{T}, which invpermutes the  rows of m1 (the columns of m1  if dims=2, simultaneously the rows  and columns if dims=(1,2)) to bring  them  to  those  of  m,  if  such  a p exists; returns nothing otherwise.  If not given {T} is taken to be {Int16}. Needs the elements of m and m1 to be sortable.\n\njulia> Perm([0 1 0;0 0 1;1 0 0],[1 0 0;0 1 0;0 0 1];dims=1)\n(1,3,2)\n\njulia> Perm([0 1 0;0 0 1;1 0 0],[1 0 0;0 1 0;0 0 1];dims=2)\n(1,2,3)\n\njulia> n=(1:30)'.*(1:30).%15;\n\njulia> m=onmats(n,Perm(1,5,2,8,12,4,7)*Perm(3,9,11,6));\n\njulia> Perm(m,n,dims=(1,2))\n(1,5,2,8,12,4,7)(3,9,11,6)\n\n\n\n\n\n","category":"method"},{"location":"perms/#PermGroups.Perms.@perm_str","page":"Permutations (Perms)","title":"PermGroups.Perms.@perm_str","text":"@perm\"...\"\n\nmakes a Perm{Int16} from a string; allows GAP-style perm\"(1,2)(5,6,7)(4,9)\". If the cycle decomposition is preceded by \"Perm{T}:\" the constructed  permutation is of type T.\n\nperm\"Perm{UInt8}:(1,2)(3,4)\"\nPerm{UInt8}: (1,2)(3,4)\n\n\n\n\n\n","category":"macro"},{"location":"perms/#PermGroups.Perms.last_moved-Union{Tuple{Perm{T}}, Tuple{T}} where T","page":"Permutations (Perms)","title":"PermGroups.Perms.last_moved","text":"last_moved(a::Perm) is the largest integer moved by a\n\n\n\n\n\nlast_moved(G::PermGroup) the largest moved point by any g∈ G\n\n\n\n\n\n","category":"method"},{"location":"perms/#PermGroups.Perms.first_moved-Union{Tuple{Perm{T}}, Tuple{T}} where T","page":"Permutations (Perms)","title":"PermGroups.Perms.first_moved","text":"first_moved(a::Perm) is the smallest integer moved by a\n\n\n\n\n\nfirst_moved(G::PermGroup) the smallest moved point by any g∈ G\n\n\n\n\n\n","category":"method"},{"location":"perms/#PermGroups.Perms.perm","page":"Permutations (Perms)","title":"PermGroups.Perms.perm","text":"perm(p::Perm) returns the data field of a Perm.\n\njulia> perm(Perm(2,3;degree=4))\n4-element Vector{Int16}:\n 1\n 3\n 2\n 4\n\n\n\n\n\n","category":"function"},{"location":"perms/#PermGroups.Perms.preimage","page":"Permutations (Perms)","title":"PermGroups.Perms.preimage","text":"preimage(i::Integer,p::Perm) or i/p\n\nthe  preimage of i by p (same as  image of i by inv(p) but does not need computing the inverse).\"\n\n\n\n\n\n","category":"function"},{"location":"perms/#PermGroups.Perms.invpermute","page":"Permutations (Perms)","title":"PermGroups.Perms.invpermute","text":"invpermute(l::AbstractVector,p::Perm)\n\nreturns  l invpermuted by  p, a vector  r of same  length as l such that r[i^p]==l[i] for i in eachindex(l). This function corresponds to the  GAP function  Permuted, but  we changed  the name  to fit  the Julia conventions since invpermute(l,p)==invpermute!(copy(l),perm(p)).\n\njulia> invpermute([5,4,6],Perm(1,2,3))\n3-element Vector{Int64}:\n 6\n 5\n 4\n\n\n\n\n\ninvpermute(m::AbstractMatrix, p1::Perm,p2::Perm)\n\ninvpermutes the rows of m by p1 and the columns of m by p2.\n\njulia> m=reshape(1:9,3,3)\n3×3 reshape(::UnitRange{Int64}, 3, 3) with eltype Int64:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> invpermute(m,Perm(1,2),Perm(2,3))\n3×3 Matrix{Int64}:\n 2  8  5\n 1  7  4\n 3  9  6\n\n\n\n\n\ninvpermute(m::AbstractMatrix,p::Perm;dims=1)\n\ninvpermutes  by p the rows, columns or  both of the matrix m depending on the value of dims.\n\njulia> m=reshape(1:9,3,3)\n3×3 reshape(::UnitRange{Int64}, 3, 3) with eltype Int64:\n 1  4  7\n 2  5  8\n 3  6  9\n\njulia> p=Perm(1,2,3)\n(1,2,3)\n\njulia> invpermute(m,p)\n3×3 Matrix{Int64}:\n 3  6  9\n 1  4  7\n 2  5  8\n\njulia> invpermute(m,p;dims=2)\n3×3 Matrix{Int64}:\n 7  1  4\n 8  2  5\n 9  3  6\n\njulia> invpermute(m,p;dims=(1,2))\n3×3 Matrix{Int64}:\n 9  3  6\n 7  1  4\n 8  2  5\n\n\n\n\n\n","category":"function"},{"location":"perms/#PermGroups.Perms.sortPerm","page":"Permutations (Perms)","title":"PermGroups.Perms.sortPerm","text":"for convenience: sortPerm(a)=Perm(sortperm(a))\n\n\n\n\n\n","category":"function"},{"location":"perms/#PermGroups.Perms.randPerm","page":"Permutations (Perms)","title":"PermGroups.Perms.randPerm","text":"randPerm([T,]n::Integer) a random permutation of 1:n of type T. If omitted T is taken to be Int16\n\n\n\n\n\n","category":"function"},{"location":"perms/#PermGroups.Perms.orbit-Tuple{Perm, Integer}","page":"Permutations (Perms)","title":"PermGroups.Perms.orbit","text":"orbit(p::Perm,i::Integer) returns the orbit of p on i.\n\n\n\n\n\n","category":"method"},{"location":"perms/#PermGroups.Perms.orbits-Tuple{Perm}","page":"Permutations (Perms)","title":"PermGroups.Perms.orbits","text":"orbits(G::PermGroup) the orbits of G on its moved points.\n\n\n\n\n\n","category":"method"},{"location":"perms/#PermGroups.Perms.order-Tuple{Perm}","page":"Permutations (Perms)","title":"PermGroups.Perms.order","text":"order(a::Perm) the order of a\n\n\n\n\n\n","category":"method"},{"location":"perms/#PermGroups.Perms.cycles-Tuple{Perm}","page":"Permutations (Perms)","title":"PermGroups.Perms.cycles","text":"cycles(a::Perm) returns the cycles of a\n\nExample\n\njulia> cycles(Perm(1,2)*Perm(4,5))\n2-element Vector{Vector{Int16}}:\n [1, 2]\n [4, 5]\n\n\n\n\n\n","category":"method"},{"location":"perms/#PermGroups.Perms.cycletype-Tuple{Perm}","page":"Permutations (Perms)","title":"PermGroups.Perms.cycletype","text":"cycletype(a::Perm,domain::AbstractVector{<:Integer};trivial=true)\n\ndomain  should be  a union  of orbits  of a.  Returns the  partition of length(domain)  associated to the conjugacy class of a in the symmetric group  of domain, with ones removed if trivial=false (in which case the partition does not depend on domain but just on support(a))\n\ncycletype(a::Perm)\n\nreturns cycletype(a,1:last_moved(a);trivial=false)\n\nExample\n\njulia> cycletype(Perm(1,2)*Perm(4,5))\n2-element Vector{Int64}:\n 2\n 2\n\njulia> cycletype(Perm(1,2)*Perm(4,5),1:5)\n3-element Vector{Int64}:\n 2\n 2\n 1\n\njulia> cycletype(Perm(1,2)*Perm(4,5),1:6)\n4-element Vector{Int64}:\n 2\n 2\n 1\n 1\n\n\n\n\n\n","category":"method"},{"location":"perms/#PermGroups.Perms.support","page":"Permutations (Perms)","title":"PermGroups.Perms.support","text":"support(a::Perm) is the sorted list of all points moved by a\n\n\n\n\n\n","category":"function"},{"location":"perms/#Base.sign","page":"Permutations (Perms)","title":"Base.sign","text":"sign(p::Perm) is the signature of  the permutation p\n\n\n\n\n\n","category":"function"},{"location":"perms/#Base.Matrix-Tuple{Perm, Any}","page":"Permutations (Perms)","title":"Base.Matrix","text":"Matrix(p::Perm,n=last_moved(p)) the  permutation matrix  for p  operating on  n points.\n\njulia> Matrix(Perm(2,3,4),5)\n5×5 Matrix{Bool}:\n 1  0  0  0  0\n 0  0  1  0  0\n 0  0  0  1  0\n 0  1  0  0  0\n 0  0  0  0  1\n\n\n\n\n\n","category":"method"},{"location":"perms/#PermGroups.Perms.restricted-Tuple{Perm, AbstractVector{<:Integer}}","page":"Permutations (Perms)","title":"PermGroups.Perms.restricted","text":"restricted(p::Perm,domain::AbstractVector{<:Integer})\n\ndomain should be a union of orbits of p; returns p restricted to domain\n\njulia> restricted(Perm(1,2)*Perm(3,4),3:4)\n(3,4)\n\n\n\n\n\n","category":"method"},{"location":"perms/#PermGroups.Perms.reflection_length-Tuple{Perm}","page":"Permutations (Perms)","title":"PermGroups.Perms.reflection_length","text":"reflection_length(p::Perm) or reflength\n\ngives  the  \"reflection  length\"  of  p  (when the symmetric group on n points to which p belongs is interpreted as a reflection group on a space of  dimension n), that is, the  minimum number of transpositions of which p is the product.\n\n\n\n\n\n","category":"method"},{"location":"perms/#PermGroups.Perms.mappingPerm","page":"Permutations (Perms)","title":"PermGroups.Perms.mappingPerm","text":"mappingPerm([::Type{T},]a::AbstractVector{<:Integer})\n\ngiven  a list  of positive  integers without  repetition a, this function finds  a  Perm{T}  p  such  that  sort(a).^p==a.  This can be used to translate  between arrangements and Perms. If  omitted T is taken to be Int16.\n\njulia> p=mappingPerm([6,7,5])\n(5,6,7)\n\njulia> (5:7).^p\n3-element Vector{Int64}:\n 6\n 7\n 5\n\n\n\n\n\nmappingPerm([::Type{T},]a,b)\n\ngiven  two lists of positive integers  without repetition a and b, this function finds a Perm{T} p such that a.^p==b. If omitted T is taken to be Int16.\n\njulia> mappingPerm([1,2,5,3],[2,3,4,6])\n(1,2,3,6,5,4)\n\n\n\n\n\n","category":"function"},{"location":"perms/#PermGroups.Perms.Perm_rowcol","page":"Permutations (Perms)","title":"PermGroups.Perms.Perm_rowcol","text":"Perm_rowcol(m1::AbstractMatrix, m2::AbstractMatrix)\n\nwhether m1 can be obtained from m2 by row/col permutations.\n\nm1 and m2 should be rectangular matrices of the same size. The function returns a Tuple of permutations (p1,p2) such that invpermute(m2,p1,p2)==m1 if such permutations exist, nothing otherwise. The eltype of m1 and m2 must be sortable.\n\njulia> a=[1 1 1 -1 -1; 2 0 -2 0 0; 1 -1 1 -1 1; 1 1 1 1 1; 1 -1 1 1 -1]\n5×5 Matrix{Int64}:\n 1   1   1  -1  -1\n 2   0  -2   0   0\n 1  -1   1  -1   1\n 1   1   1   1   1\n 1  -1   1   1  -1\n\njulia> b=[1 -1 -1 1 1; 1 1 -1 -1 1; 1 -1 1 -1 1; 2 0 0 0 -2; 1 1 1 1 1]\n5×5 Matrix{Int64}:\n 1  -1  -1   1   1\n 1   1  -1  -1   1\n 1  -1   1  -1   1\n 2   0   0   0  -2\n 1   1   1   1   1\n\njulia> p1,p2=Perm_rowcol(a,b)\n((1,3,5,4,2), (3,4,5))\n\njulia> invpermute(b,p1,p2)==a\ntrue\n\n\n\n\n\n","category":"function"},{"location":"groups/#Groups","page":"Groups","title":"Groups","text":"","category":"section"},{"location":"groups/#PermGroups.Groups","page":"Groups","title":"PermGroups.Groups","text":"This module gives some basic functionality on groups.\n\nGroup  is  an  abstract  type,  but  the  following is assumed of a group G of one of its concrete implementations:\n\nThe function generators(G) returns the list of generators of G (this can also be abbreviated gens(G)).\nThe function one(G) returns the identity element of G.\n\nThere  is a constructor of a group with arbitrary type elements, Group(l) where  l isa AbstractVector{T} constructs a Groupof{T} which knows only the general methods in this module.\n\nExamples\n\njulia> G=Group([-1]) # the group (of order 2) generated by -1\nGroup([-1])\n\njulia> generators(G), number_of_generators(G)\n([-1], 1)\n\njulia> minimal_words(G)\nOrderedDict{Int64, Vector{Int64}} with 2 entries:\n  1  => []\n  -1 => [1]\n\nThe  next example  uses Group(AbstractVector{<:Perm})  which constructs a PermGroup which has more efficient methods.\n\njulia> G=Group(Perm(1,2),Perm(1,2,3))\nGroup((1,2),(1,2,3))\n\njulia> gens(G) # same as generators\n2-element Vector{Perm{Int16}}:\n (1,2)\n (1,2,3)\n\njulia> ngens(G) # same as number_of_generators\n2\n\njulia> minimal_words(G)\nOrderedDict{Perm{Int16}, Vector{Int64}} with 6 entries:\n  ()      => []\n  (1,2)   => [1]\n  (1,2,3) => [2]\n  (1,3)   => [1, 2]\n  (2,3)   => [2, 1]\n  (1,3,2) => [2, 2]\n\nfor  more  information  on  the  functions  defined in this module, look at Group, comm,     orbit,   orbits, transversal,   words_transversal,  centralizer, stabilizer,         center,         normalizer, some_words,         minimal_words,        word, in,     elements,    length,    order, conjugacy_class,  conjugacy_classes, classreps,  number_of_conjugacy_classes, fusion_conjugacy_classes,                position_class, isabelian,  iscyclic,  istrivial,  rand, transporting_element,      intersect,     Hom, kernel,  Coset, NormalCoset\n\n\n\n\n\n","category":"module"},{"location":"groups/#PermGroups.Groups.Group","page":"Groups","title":"PermGroups.Groups.Group","text":"(G::Group)(i...)\n\nA Group used as a function takes integer arguments in eachindex(gens(W)). This  constructs  the  element  of  G  product of the generators with the specified  indices. An argument  can also be  negative, then the inverse of the corresponding generator is used.\n\njulia> G=Group(Perm(1,2),Perm(1,2,3))\nGroup((1,2),(1,2,3))\n\njulia> G(2,1,-2) # returns gens(G)[2]*gens(G)[1]/gens(G)[2]\n(1,3)\n\n\n\n\n\nGroup(l::AbstractVector{T}[,one]) where T\n\nA  group may be constructed  from a list of  l elements of the same type. These  elements must respond to  the functions * and  inv. If it is not possible  to compute  one from  l (because  l[1] does  not respond to one,  or  l  is  empty  and  T  does  not respond to one), then the identity element of the group must be given as a second argument.\n\njulia> G=Group([[-1 -1;1 0]])\nGroup([[-1 -1; 1 0]])\n\njulia> elements(G)\n3-element Vector{Matrix{Int64}}:\n [1 0; 0 1]\n [-1 -1; 1 0]\n [0 1; -1 -1]\n\n\n\n\n\n","category":"type"},{"location":"groups/#PermGroups.Groups.generators","page":"Groups","title":"PermGroups.Groups.generators","text":"gens(G::Group) or generators(G::Group) is the Vector of generators of G.\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.number_of_generators","page":"Groups","title":"PermGroups.Groups.number_of_generators","text":"ngens(G::Group) or number_of_generators(G::Group) is the number of generators of G.\n\n\n\n\n\n","category":"function"},{"location":"groups/#Base.one-Tuple{Group}","page":"Groups","title":"Base.one","text":"one(G::Group) returns the identity element of G.\n\n\n\n\n\n","category":"method"},{"location":"groups/#PermGroups.Groups.orders_of_generators","page":"Groups","title":"PermGroups.Groups.orders_of_generators","text":"orders_of_generators(G::Group) or ordergens\n\nThe list of orders of the generators (this may be expensive to compute so could be worth being cached in G).\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.ontuples","page":"Groups","title":"PermGroups.Groups.ontuples","text":"ontuples(t,g)\n\nAssume  that t is a  Vector or a NTuple.  ontuples is the action of g given by (t,g)->map(x->x^g,t).\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.onsets","page":"Groups","title":"PermGroups.Groups.onsets","text":"onsets(s,g)\n\nAssume that s is a set, represented as a sorted list without repetitions. onsets is the action of g given by (s,g)->sort!(map(x->x^g,s)).\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Perms.orbit-Tuple{AbstractVector, Any}","page":"Groups","title":"PermGroups.Perms.orbit","text":"orbit(gens::AbstractVector,p,action::Function=^)\n\norbit(G::Group,p,action::Function=^)\n\nthe orbit of point p under repeated action of generators gens. The type of  point p should be hashable. The  default action of a group element is ^.  For example if g is a permutation  and p an integer, p^g is the image  of p by g; if h and  g are group elements, then h^g is the conjugate  inv(g)*h*g. If  a group  is given  instead of  generators, the orbit under gens(G) is returned.\n\njulia> orbit([Perm(1,2),Perm(2,3)],1)\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> orbit([Perm(1,2),Perm(2,3)],[1,3],ontuples)\n6-element Vector{Vector{Int64}}:\n [1, 3]\n [2, 3]\n [1, 2]\n [3, 2]\n [2, 1]\n [3, 1]\n\njulia> orbit([Perm(1,2),Perm(2,3)],[1,3],(v,g)->sort(v.^g)) # \"OnSets\"\n3-element Vector{Vector{Int64}}:\n [1, 3]\n [2, 3]\n [1, 2]\n\n\n\n\n\n","category":"method"},{"location":"groups/#PermGroups.Perms.orbits-Tuple{Group, Any}","page":"Groups","title":"PermGroups.Perms.orbits","text":"orbits(gens::Vector,v,action=^;trivial=true)\n\norbits(G,v,action=^;trivial=true)\n\nthe  orbits on v  of the repeated  action of gens;  the elements of v should  be hashable. If a  group is given instead  of generators, the orbit under  gens(G) is returned. If trivial=false the one-element orbits are not returned.\n\njulia> G=Group(Perm(1,2),Perm(2,3));\njulia> orbits(G,1:4)\n2-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [4]\n\n\n\n\n\n","category":"method"},{"location":"groups/#PermGroups.Groups.elements-Tuple{Group}","page":"Groups","title":"PermGroups.Groups.elements","text":"elements(G::Group) the list of elements of G\n\n\n\n\n\n","category":"method"},{"location":"groups/#PermGroups.Groups.transversal","page":"Groups","title":"PermGroups.Groups.transversal","text":"transversal(G::Group,p,action::Function=^)\n\nreturns  an OrderedDict t with keys  orbit(G,p,action) and where t[x] is an element  of  G  such  that  x==action(p,t[x]).  Like  orbit,  it thus requires the type of p to be hashable.\n\njulia> G=Group(Perm(1,2),Perm(2,3));\njulia> transversal(G,1)\nOrderedDict{Int64, Perm{Int16}} with 3 entries:\n  1 => ()\n  2 => (1,2)\n  3 => (1,3,2)\n\norbit functions can take any action of G as keyword argument\n\njulia> transversal(G,(1,2),ontuples)\nOrderedDict{Tuple{Int64, Int64}, Perm{Int16}} with 6 entries:\n  (1, 2) => ()\n  (2, 1) => (1,2)\n  (1, 3) => (2,3)\n  (3, 1) => (1,3,2)\n  (2, 3) => (1,2,3)\n  (3, 2) => (1,3)\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.words_transversal","page":"Groups","title":"PermGroups.Groups.words_transversal","text":"words_transversal(gens,p,action::Function=^)\n\nA   transversal   recording   words.   returns   a  Dict  t  with  keys orbit(gens,p,action) and where t[x] is a sequence of integers such that x==action(p,prod(gens[t[x]])),  that is for each element x of the orbit of p describes as a word in gens an element bringing p to x.\n\njulia> words_transversal([Perm(1,2),Perm(2,3)],1)\nOrderedDict{Int64, Vector{Int64}} with 3 entries:\n  1 => []\n  2 => [1]\n  3 => [1, 2]\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.centralizer","page":"Groups","title":"PermGroups.Groups.centralizer","text":"centralizer(G::Group,p,action=^)\n\ncomputes  the subgroup of elements g of G such that action(p,g)==p.\n\njulia> G=Group(Perm(1,2),Perm(1,2,3));\njulia> centralizer(G,1)\nGroup((2,3))\n\n\n\n\n\ncentralizer(G::Group,H::Group) the centralizer in G of the group H\n\njulia> G=Group(Perm(1,2),Perm(1,2,3))\nGroup((1,2),(1,2,3))\n\njulia> centralizer(G,Group(Perm(1,2)))\nGroup((1,2))\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.center","page":"Groups","title":"PermGroups.Groups.center","text":"center(G::Group) the center of G\n\njulia> G=Group(Perm(1,2),Perm(3,4),Perm(1,3)*Perm(2,4))\nGroup((1,2),(3,4),(1,3)(2,4))\n\njulia> center(G)\nGroup((1,2)(3,4))\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.stabilizer","page":"Groups","title":"PermGroups.Groups.stabilizer","text":"stabilizer(G::Group,s,action=^)\n\ncomputes  the subgroup of elements g of G such that action(p,g)==p.\n\njulia> G=Group(Perm(1,2),Perm(1,2,3,4))\nGroup((1,2),(1,2,3,4))\n\nAssume that s is a set, represented as a sorted list without repetitions. onsets is the  action  of  g∈  G  given  by  (g,p)->sort(p.^g).\n\njulia> stabilizer(G,[1,2],onsets)\nGroup((3,4),(1,2))\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.normalizer","page":"Groups","title":"PermGroups.Groups.normalizer","text":"normalizer(G::Group,H::Group) the normalizer of H in G\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.word-Tuple{Group, Any}","page":"Groups","title":"PermGroups.Groups.word","text":"word(G::Group,w) a minimal word in gens(G) representing element w of G\n\n\n\n\n\n","category":"method"},{"location":"groups/#PermGroups.Groups.comm","page":"Groups","title":"PermGroups.Groups.comm","text":"comm(a,b) or commutator(a,b) is a^-1*b^-1*a*b\n\n\n\n\n\n","category":"function"},{"location":"groups/#Base.length-Tuple{Group}","page":"Groups","title":"Base.length","text":"length(G::Group) the number of elements of G.\n\nlength(T,G) do the computation with the integer type T.\n\n\n\n\n\n","category":"method"},{"location":"groups/#PermGroups.Groups.classreps-Tuple{Group}","page":"Groups","title":"PermGroups.Groups.classreps","text":"class_representatives(G::Group)  or classreps\n\nrepresentatives  of  conjugacy  classes  of  G.  By  default  queries the attribute  G.classreps, and if this attribute  is present it will be used by conjugacy_classes.\n\n\n\n\n\n","category":"method"},{"location":"groups/#PermGroups.Groups.conjugacy_classes","page":"Groups","title":"PermGroups.Groups.conjugacy_classes","text":"conjugacy_classes(G::Group) conjugacy classes of G (as a Vector{ConjugacyClass})\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.conjugacy_class","page":"Groups","title":"PermGroups.Groups.conjugacy_class","text":"conjugacy_class(G::Group,g) the class of g\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.number_of_conjugacy_classes","page":"Groups","title":"PermGroups.Groups.number_of_conjugacy_classes","text":"number_of_conjugacy_classes(G::Group) or nconjugacy_classes\n\nthe number of conjugacy classes of G\"\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.position_class","page":"Groups","title":"PermGroups.Groups.position_class","text":"position_class(G::Group,g) index of conjugacy class to which g belongs\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.fusion_conjugacy_classes","page":"Groups","title":"PermGroups.Groups.fusion_conjugacy_classes","text":"fusion_conjugacy_classes(H::Group,G::Group)\n\nA Vector{Int} telling for each conjugacy class of subgroup H of which class of G is is a subset\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.some_words","page":"Groups","title":"PermGroups.Groups.some_words","text":"some_words(G::Group)\n\nreturns  a Dict  giving for  each element  of G  a positive word in the generators representing it. It is faster than minimal_words but the words are not guaranteed minimal.\n\njulia> G=Group(Perm(1,2),Perm(1,2,3));\njulia> some_words(G)\nOrderedDict{Perm{Int16}, Vector{Int64}} with 6 entries:\n  ()      => []\n  (1,2)   => [1]\n  (1,2,3) => [2]\n  (1,3)   => [1, 2]\n  (2,3)   => [2, 1]\n  (1,3,2) => [1, 2, 1]\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.minimal_words","page":"Groups","title":"PermGroups.Groups.minimal_words","text":"minimal_words(G::Group)\n\nreturns  a Dict giving for each element of G a minimal positive word in the generators representing it.\n\njulia> G=Group(Perm(1,2),Perm(1,2,3));\njulia> minimal_words(G)\nOrderedDict{Perm{Int16}, Vector{Int64}} with 6 entries:\n  ()      => []\n  (1,2)   => [1]\n  (1,2,3) => [2]\n  (1,3)   => [1, 2]\n  (2,3)   => [2, 1]\n  (1,3,2) => [2, 2]\n\n\n\n\n\nminimal_words(G::Group,w)\n\nGives all expressions of w as words in the generators of G of minimal length (uses minimal_words(G)).\n\njulia> G=Group(Perm(1,2),Perm(2,3));\n\njulia> minimal_words(G,Perm(1,3))\n2-element Vector{Vector{Int64}}:\n [1, 2, 1]\n [2, 1, 2]\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.words-Tuple{Group}","page":"Groups","title":"PermGroups.Groups.words","text":"words(G::Group;minimal=false)\n\nreturns  a  for  each  element  of  G  a  positive word in the generators representing  it. These words are not guaranteed minimal unless the keyword minimal=true is given (which makes the function somewhat slower).\n\njulia> G=Group(Perm(1,2),Perm(1,2,3));\n\njulia> words(G)\n6-element Vector{Vector{Int64}}:\n []\n [1]\n [2]\n [1, 2]\n [2, 1]\n [1, 2, 1]\n\njulia> words(G;minimal=true)\n6-element Vector{Vector{Int64}}:\n []\n [1]\n [2]\n [1, 2]\n [2, 1]\n [2, 2]\n\n\n\n\n\n","category":"method"},{"location":"groups/#PermGroups.Groups.transporting_element","page":"Groups","title":"PermGroups.Groups.transporting_element","text":"transporting_elt(G,p,q,action=^)    or transporting_element(G,p,q,action=^)\n\nreturns  an  element  g∈  G  such  that  p^g==q (or action(p,g)==q if action is given), if such a g exists, and nothing otherwise. The set of possible g forms a right coset of the centralizer of p in G.\n\njulia> g=Group(perm\"(1,2,3)(6,7)\",perm\"(3,4,5)(7,8)\")\nGroup((1,2,3)(6,7),(3,4,5)(7,8))\n\njulia> transporting_elt(g,1,5)\n(1,5,4,3,2)\n\njulia> transporting_elt(g,1,6)\n\njulia> transporting_elt(g,[1,2,3,4],[2,3,4,5],(s,g)->sort(s.^g))\n(1,2,3,4,5)(6,7,8)\n\njulia> transporting_elt(g,[1,2,3,4],[3,4,5,2],(s,g)->s.^g)\n\n\n\n\n\n","category":"function"},{"location":"groups/#Base.intersect-Tuple{Group, Group}","page":"Groups","title":"Base.intersect","text":"intersect(G::Group, H::Group) the intersection as a group\n\n\n\n\n\n","category":"method"},{"location":"groups/#Base.rand-Tuple{Group}","page":"Groups","title":"Base.rand","text":"rand(W::Group) a random element of W\n\n\n\n\n\n","category":"method"},{"location":"groups/#PermGroups.Groups.isabelian","page":"Groups","title":"PermGroups.Groups.isabelian","text":"isabelian(G::Group) whether G is abelian\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.iscyclic","page":"Groups","title":"PermGroups.Groups.iscyclic","text":"iscyclic(G::Group) whether G is cyclic\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.istrivial","page":"Groups","title":"PermGroups.Groups.istrivial","text":"istrivial(G::Group) whether G is trivial\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.Hom","page":"Groups","title":"PermGroups.Groups.Hom","text":"Hom(S::Group,T::Group,images)\n\nbuilds an object representing the homomorphism from S to T which maps gens(S) to images.\n\njulia> S=Group(Perm(1,2),Perm(2,3))\nGroup((1,2),(2,3))\n\njulia> T=Group(Perm(1,2))\nGroup((1,2))\n\njulia> h=Hom(S,T,[T(1),T(1)])\nHom(Group((1,2),(2,3))→ Group((1,2));[(1,2), (2,3)]↦ [(1,2), (1,2)]\n\njulia> h(S(1,2)) # the image by h\n()\n\n\n\n\n\n","category":"type"},{"location":"groups/#PermGroups.Groups.kernel","page":"Groups","title":"PermGroups.Groups.kernel","text":"kernel(h::Hom) the kernel of the homomorphism h\n\n\n\n\n\n","category":"function"},{"location":"groups/#PermGroups.Groups.Coset","page":"Groups","title":"PermGroups.Groups.Coset","text":"Coset(G::Group,phi=one(G))  constructs the (left)  coset G.phi where G isa  Group{<:T} and phi isa  T, as an object  of type Cosetof{T}. This general  coset knows only the general methods for a coset C=G.phi defined in this module, which are\n\nGroup(C) returns G.\nisone(C) returns true iff phi in G\none(C) returns the trivial coset G.1\nlength(C) returns length(G)\nelements(C) returns elements(G).*Ref(phi)\nx in C returns x/phi in G\n\n\n\n\n\n","category":"type"},{"location":"groups/#PermGroups.Groups.NormalCoset","page":"Groups","title":"PermGroups.Groups.NormalCoset","text":"NormalCoset(G::Group,phi=one(G))  constructs the coset C=G.phi where G isa  Group{<:T} and phi isa T,  as an object of type NormalCosetof{T}. It  is assumed that phi normalizes G. This general coset knows only the general  methods defined for normal cosets in the module Groups, which in addition to those defined for cosets (see Coset) are\n\ninv(C) return G.inv(phi) (assumed equal to inv(phi).G)\nC*D given another coset G.psi returns G.phi*psi\nC/D given another coset G.psi returns G.phi*inv(psi)\nC^D given another coset G.psi returns G.inv(psi)*phi*psi\nC^n returns G.phi^n\norder(C) the smallest n such that isone(C^n)\n\nThe  conjugacy  classes  of  a  normal  coset  G.phi  are relative to the conjugation action of G on G.phi. We have the functions conjugacy_classes, nconjugacy_classes, classreps, position_class.\n\nFinally  the function  G/H for  two groups  constructs the  quotient as a group of NormalCosets, and fusion_conjugacy_classes(H::NormalCoset,G::NormalCoset)   expresses   the fusion of conjugacy classes.\n\n\n\n\n\n","category":"type"},{"location":"#package-PermGroups","page":"package PermGroups","title":"package PermGroups","text":"This package implements permutations (Perms), groups (Groups) and combines them to make permutation groups (PermGroups). \n\nIt just depends on the package Combinat. The modules Perms and Groups could be independent packages of their own.","category":"section"},{"location":"permgroups/#Permutation-groups-(PermGroups)","page":"Permutation groups (PermGroups)","title":"Permutation groups (PermGroups)","text":"","category":"section"},{"location":"permgroups/#PermGroups","page":"Permutation groups (PermGroups)","title":"PermGroups","text":"This  module is a port  of some GAP functionality  on permutation groups. A PermGroup is a Group where gens are Perms. It depends on the modules Groups and Perms which could be independent packages on their own.\n\njulia> G=Group([Perm(i,i+1) for i in 1:2])\nGroup((1,2),(2,3))\n\njulia> collect(G) # PermGroups are iterators over their elements\n6-element Vector{Perm{Int16}}:\n ()\n (1,2)\n (1,3,2)\n (2,3)\n (1,2,3)\n (1,3)\n\njulia> last_moved(G)  # maximum moved point of any element of `G`\n3\n\njulia> orbits(G) # the orbits are orbits on points it moves\n1-element Vector{Vector{Int16}}:\n [1, 2, 3]\n\njulia> Perm(1,2) in G\ntrue\n\njulia> Perm(1,2,4) in G\nfalse\n\nelements,   in  and   other  functions   are  computed   on  G  using Schreier-Sims theory, that is computing the following\n\njulia> get_stabchain(G)\nb:1 c:Group((1,2),(2,3))\n  δ:1=>(),2=>(1,2),3=>(1,3,2)\nb:2 c:Group((2,3))\n  δ:2=>(),3=>(2,3)\n\nSee   Stabchain,stabchain,get_stabchain   for explanations.\n\nThere are efficient methods for PermGroups for the functions in, length, elements, position_class. The function on_classes determines the permutation  of the conjugacy classes effected by an automorphism. Finally, we   give  application  to  the  group   of  simultaneous  row  and  column permutations of a matrix: see stab_onmats, Perm.\n\nfinally, benchmarks on julia 1.9\n\njulia> @btime collect(symmetric_group(8));\n  1.921 ms (50128 allocations: 3.29 MiB)\n\njulia> @btime some_words(symmetric_group(8));\n  6.441 ms (80971 allocations: 10.88 MiB)\n\njulia> @btime elements(symmetric_group(8)); # Gap takes 8 ms\n  1.565 ms (49539 allocations: 3.71 MiB)\n\njulia> rubik_gens=[\n  perm\"(1,3,8,6)(2,5,7,4)(9,33,25,17)(10,34,26,18)(11,35,27,19)\",\n  perm\"(9,11,16,14)(10,13,15,12)(1,17,41,40)(4,20,44,37)(6,22,46,35)\",\n  perm\"(17,19,24,22)(18,21,23,20)(6,25,43,16)(7,28,42,13)(8,30,41,11)\",\n  perm\"(25,27,32,30)(26,29,31,28)(3,38,43,19)(5,36,45,21)(8,33,48,24)\",\n  perm\"(33,35,40,38)(34,37,39,36)(3,9,46,32)(2,12,47,29)(1,14,48,27)\",\n  perm\"(41,43,48,46)(42,45,47,44)(14,22,30,38)(15,23,31,39)(16,24,32,40)\"];\n\njulia> @btime length(Int128,Group(rubik_gens)) # Gap takes 5ms\n  4.906 ms (104874 allocations: 13.64 MiB)\n43252003274489856000\n\nNote  the use of  Int128 in length:  the computation does  not fit in an Int64.\n\n\n\n\n\n","category":"module"},{"location":"permgroups/#PermGroups.Perms.last_moved-Tuple{PermGroup}","page":"Permutation groups (PermGroups)","title":"PermGroups.Perms.last_moved","text":"last_moved(a::Perm) is the largest integer moved by a\n\n\n\n\n\nlast_moved(G::PermGroup) the largest moved point by any g∈ G\n\n\n\n\n\n","category":"method"},{"location":"permgroups/#PermGroups.Perms.first_moved-Tuple{PermGroup}","page":"Permutation groups (PermGroups)","title":"PermGroups.Perms.first_moved","text":"first_moved(a::Perm) is the smallest integer moved by a\n\n\n\n\n\nfirst_moved(G::PermGroup) the smallest moved point by any g∈ G\n\n\n\n\n\n","category":"method"},{"location":"permgroups/#Base.in-Tuple{Perm, PermGroup}","page":"Permutation groups (PermGroups)","title":"Base.in","text":"x in G for G a group: whether x is an element of G\n\n\n\n\n\n","category":"method"},{"location":"permgroups/#PermGroups.Stabchain","page":"Permutation groups (PermGroups)","title":"PermGroups.Stabchain","text":"A  Stabchain  is  a  Vector{Stablink}  S=[S₁,…,Sₖ]  associated  to  a PermGroup{T}  G. The Vector{T} given by B=[S₁.b,…,Sₖ.b] is called a base   for  G.   At  each   stage  one   has  Sᵢ.c=C_G(B[1:i-1])  and Sᵢ.δ=transversal(Sᵢ.c,Sᵢ.b)\n\n\n\n\n\n","category":"type"},{"location":"permgroups/#PermGroups.stabchain-Tuple{PermGroup, Any}","page":"Permutation groups (PermGroups)","title":"PermGroups.stabchain","text":"stabchain(G::PermGroup{T},B=T[];trans=transversal)where T\n\nConstructs a Stabchain for G [starting with base B]\n\nThe  code refers  to the  Handbook of  computational group theory, by Holt, Eick,  O'Brien, section 4.4.2.\n\ntrans could be SchreierTransversal.\n\n\n\n\n\n","category":"method"},{"location":"permgroups/#PermGroups.get_stabchain-Tuple{PermGroup}","page":"Permutation groups (PermGroups)","title":"PermGroups.get_stabchain","text":"This function adds to G a stabchain\n\n\n\n\n\n","category":"method"},{"location":"permgroups/#PermGroups.on_classes-Tuple{Any, Any}","page":"Permutation groups (PermGroups)","title":"PermGroups.on_classes","text":"on_classes(G, aut)\n\naut  is an automorphism of  the group G (for  a permutation group, this could  be  given  as  a  permutation  normalizing  G).  The result is the permutation of 1:nconjugacy_classes(G) induced by aut.\n\njulia> W=Group(Perm(1,2),Perm(2,3),Perm(4,5),Perm(5,6))\nGroup((1,2),(2,3),(4,5),(5,6))\n\njulia> on_classes(W,Perm(1,4,2,5,3,6))\n(2,4)(3,7)(6,8)\n\n\n\n\n\n","category":"method"},{"location":"permgroups/#PermGroups.symmetric_group","page":"Permutation groups (PermGroups)","title":"PermGroups.symmetric_group","text":"symmetric_group(n::Int)  The symmetric group of degree n\n\n\n\n\n\n","category":"function"},{"location":"permgroups/#PermGroups.Perms.onmats","page":"Permutation groups (PermGroups)","title":"PermGroups.Perms.onmats","text":"onmats(m::AbstractMatrix,g::Perm) synonym for invpermute(m,g;dims=(1,2)) or invpermute(m,g,g).\n\n\n\n\n\n","category":"function"},{"location":"permgroups/#PermGroups.stab_onmats","page":"Permutation groups (PermGroups)","title":"PermGroups.stab_onmats","text":"stab_onmats([G,]M;extra=nothing)\n\nIf  onmats(m,p)=^(M,p;dims=(1,2)), and  the argument  G is given (which should   be  a  PermGroup)   this  is  just   a  fast  implementation  of centralizer(G,M,onmats).   If  G   is  omitted   it  is   taken  to  be symmetric_group(size(M,1)).  The  program  uses sophisticated algorithms, and  can handle matrices up to 80×80. If a list extra is given the result centralizes also extra.\n\njulia> stab_onmats((1:30)'.*(1:30).%15)\nGroup((1,16),(4,19),(11,26),(14,29),(2,17),(7,22),(8,23),(13,28),(6,21),(9,24),(1,4)(2,8)(3,12)(6,9)(7,13)(11,14)(16,19)(17,23)(18,27)(21,24)(22,28)(26,29),(3,18),(12,27),(1,11)(2,7)(4,14)(5,10)(8,13)(16,26)(17,22)(19,29)(20,25)(23,28),(5,20),(10,25),(15,30))\n\n\n\n\n\n","category":"function"},{"location":"permgroups/#PermGroups.Perm_onmats","page":"Permutation groups (PermGroups)","title":"PermGroups.Perm_onmats","text":"Perm_onmats(M, N[, m ,n])\n\nreturns p such that onmats(N,p)=M if it exists, nothing otherwise; so is just an efficient version of transporting_elt(symmetric_group(size(M,1)),N,M,onmats)  If  in  addition the vectors m and n are given, p should satisfy invpermute(n,p)=m.\n\n\n\n\n\n","category":"function"},{"location":"permgroups/#PermGroups.ProdIterator","page":"Permutation groups (PermGroups)","title":"PermGroups.ProdIterator","text":"A  ProdIterator([i₁,…,iₙ])  takes  a  list  i₁,…,iₙ  of  iterators  and iterates  on all the products i₁[j₁]*…*iₙ[jₙ]  (where the inner loop jₙ runs  the  fastest).  It  tries  to  be  fast  by re-using partial products i₁[j₁]*…*iₖ[jₖ] for k<n.\n\nIt is used internally for iterating over a permutation group.\n\n\n\n\n\n","category":"type"}]
}
